<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Runner vs Attacker - Online Multiplayer</title>
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <!-- Game Engine -->
    <script src="js/config.js"></script>
    <script src="js/game-engine.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #222;
            font-family: 'Consolas', monospace;
            color: white;
            overflow: hidden;
            user-select: none;
        }

        .pixel-art {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* Lobby Styles */
        #lobby-screen {
            text-align: center;
            padding: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            border: 2px solid #444;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            z-index: 200;
            position: absolute;
        }

        .btn {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #00c6ff, #007bff);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            margin: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4444, #cc0000);
        }

        /* Game Container (from single.html) */
        #game-container {
            width: 800px;
            height: 300px;
            border: 4px solid #666;
            background-image: url('assets/background.png');
            background-size: cover;
            background-position: center -50px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            display: none;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            z-index: 20;
            box-sizing: border-box;
            pointer-events: none;
        }

        #p1-status,
        #p2-status {
            width: 250px;
        }

        #p2-status {
            text-align: right;
        }

        .large-score {
            color: #0056b3;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 1px 1px 0 #fff;
        }

        #timer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #333;
            text-shadow: 2px 2px 0 #fff;
            z-index: 21;
        }

        #timer.warning {
            color: #ff4444;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.1);
            }
        }

        #stamina-box {
            position: absolute;
            transform: translateX(-50%);
            width: 80px;
            height: 12px;
            background: #333;
            border: 2px solid #000;
            border-radius: 10px;
            overflow: hidden;
            z-index: 25;
        }

        #stamina-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ffcc00, #ff4444);
            transition: width 0.1s linear;
        }

        #stamina-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-size: 10px;
            line-height: 15px;
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
        }

        .status-indicator {
            position: absolute;
            bottom: 80px;
            right: 40px;
            font-weight: bold;
            font-size: 14px;
            display: none;
            z-index: 30;
        }

        .charging {
            animation: player-shake 0.1s infinite !important;
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-2px);
            }

            75% {
                transform: translateX(2px);
            }
        }

        #ground {
            width: 100%;
            height: 45px;
            background-image: url('assets/ground.png');
            overflow: hidden;
            background-size: auto 45px;
            background-repeat: repeat-x;
            background-position: 0 0;
            position: absolute;
            bottom: -5px;
            left: 0;
            z-index: 10;
        }

        #player1,
        #player2 {
            position: absolute;
            width: 64px;
            height: 64px;
            background-repeat: no-repeat;
            background-size: auto 64px;
            z-index: 15;
            transition: transform 0.1s;
            /* Smooth rotation */
        }

        #player2.cooldown {
            filter: grayscale(100%);
            opacity: 0.7;
        }

        .obstacle {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 11;
            will-change: transform;
        }

        /* Character Selection UI */
        #char-select {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        #char-grid {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .char-card {
            width: 100px;
            height: 140px;
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #222;
            position: relative;
            transition: all 0.2s;
        }

        .char-card.selected {
            border-color: #00c6ff;
            box-shadow: 0 0 15px #00c6ff;
        }

        .char-preview {
            width: 64px;
            height: 64px;
            background-repeat: no-repeat;
            background-size: auto 64px;
            image-rendering: pixelated;
            margin-bottom: 10px;
        }

        .char-name {
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 60;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        #mmr-change-display {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #leaderboard-table th {
            border-bottom: 1px solid #666;
        }

        #leaderboard-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }

        #leaderboard-table tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>

<body>
    <!-- Lobby Screen -->
    <div id="lobby-screen">
        <h1 style="color: #ffcc00; text-shadow: 2px 2px 0 #333; font-size: 48px; margin-bottom: 30px;">
            ONLINE MULTIPLAYER
        </h1>
        <div id="my-rank" style="font-size: 18px; margin-bottom: 20px; color: #ffd700;">
            Loading Rank...
        </div>

        <div id="connection-status" style="font-size: 18px; margin-bottom: 20px; color: #aaa;">
            Connecting to server...
        </div>

        <button id="quick-match-btn" class="btn" disabled>
            ‚ö° QUICK MATCH
        </button>

        <button id="cancel-match-btn" class="btn btn-danger" style="display:none;">
            ‚ùå CANCEL
        </button>

        <div id="match-status" style="margin-top: 20px; font-size: 20px; color: #4caf50; min-height: 30px;"></div>

        <button onclick="location.href='index.html'" class="btn"
            style="background: #444; margin-top: 40px; font-size: 16px;">
            ‚¨ÖÔ∏è Back to Menu
        </button>
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <!-- Character Selection UI -->
        <div id="char-select">
            <h1>SELECT YOUR CHARACTER</h1>
            <div id="char-grid"></div>
            <div class="controls-hint">
                <div class="p1-hint">Use ARROW KEYS to select, SPACE to confirm</div>
                <div id="opponent-status" style="margin-top:10px; color:#aaa;">Waiting for opponent...</div>
            </div>
        </div>

        <div id="ui-layer">
            <div id="p1-status">
                <!-- id="p1-name" Ï∂îÍ∞Ä -->
                <div id="p1-name" style="color:#007bff; font-weight:bold; margin-bottom:5px;">PLAYER 1</div>
                <div class="large-score" id="p1-score">0</div>
            </div>
            <div id="timer">60</div>
            <div id="p2-status">
                <!-- id="p2-name" Ï∂îÍ∞Ä -->
                <div id="p2-name" style="color:#ff4444; font-weight:bold; margin-bottom:5px;">PLAYER 2</div>
                <div class="large-score" id="p2-score">0</div>
            </div>
        </div>

        <div id="ground"></div>
        <div id="obstacles-layer"></div>
        <div id="stamina-box">
            <div id="stamina-bar"></div>
            <div id="stamina-text">100</div>
        </div>
        <div id="player1" class="pixel-art"></div>
        <div id="player2" class="pixel-art"></div>

        <div id="debug-box"></div>

        <div class="status-indicator" id="charge-indicator" style="display: none;">‚ö†Ô∏è CHARGING!</div>
        <div class="status-indicator" id="cooldown-indicator" style="display: none;">‚è≥ COOLDOWN</div>

        <div id="game-over">
            <h1 id="winner-msg" style="font-size: 48px; color: #ffcc00; margin-bottom: 20px;">GAME OVER</h1>
            <p id="game-over-reason" style="font-size: 24px; color: #aaa; margin-bottom: 20px;"></p>

            <div id="mmr-change-display" style="margin: 20px 0; font-size: 24px; font-weight: bold;"></div>

            <div id="leaderboard-container"
                style="background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px; width: 80%; max-width: 600px;">
                <h3 style="margin-top: 0; color: #ffd700; border-bottom: 1px solid #666; padding-bottom: 10px;">üèÜ TOP
                    10 PLAYERS</h3>
                <table id="leaderboard-table" style="width: 100%; text-align: left; border-collapse: collapse;">
                    <thead>
                        <tr style="color: #aaa;">
                            <th style="padding: 10px;">Rank</th>
                            <th style="padding: 10px;">Player</th>
                            <th style="padding: 10px;">MMR</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Rows will be added here -->
                    </tbody>
                </table>
            </div>

            <div style="display: flex; gap: 20px;">
                <button id="go-lobby-btn" class="btn" style="background: #444;">üè† Main Menu</button>
                <button id="play-again-btn" class="btn">üîÑ Quick Match</button>
            </div>
        </div>




    </div>

    <script>
        // --- Configuration & Auth ---
        const API_URL = window.location.origin;
        const authToken = localStorage.getItem('authToken');
        const username = localStorage.getItem('username');
        const userId = localStorage.getItem('userId');

        if (!authToken || !username || !userId) {
            alert('Please login to play online mode');
            window.location.href = 'login.html';
        }

        // --- Socket.IO ---
        const socket = io(API_URL);

        // --- DOM Elements ---
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameContainer = document.getElementById('game-container');
        const charSelectScreen = document.getElementById('char-select');
        const connectionStatus = document.getElementById('connection-status');
        const quickMatchBtn = document.getElementById('quick-match-btn');
        const cancelMatchBtn = document.getElementById('cancel-match-btn');
        const matchStatus = document.getElementById('match-status');

        const els = {
            p1: document.getElementById('player1'),
            p2: document.getElementById('player2'),
            ground: document.getElementById('ground'),
            obsLayer: document.getElementById('obstacles-layer'),
            timer: document.getElementById('timer'),
            p1Score: document.getElementById('p1-score'),
            p2Score: document.getElementById('p2-score'),
            staminaBox: document.getElementById('stamina-box'),
            staminaBar: document.getElementById('stamina-bar'),
            staminaText: document.getElementById('stamina-text'),
            chargeInd: document.getElementById('charge-indicator'),
            coolInd: document.getElementById('cooldown-indicator'),
            gameOver: document.getElementById('game-over'),
            winnerMsg: document.getElementById('winner-msg'),
            gameOverReason: document.getElementById('game-over-reason')
        };

        // --- Game State ---
        let currentRoom = null;
        let myRole = null; // 'player1' or 'player2'
        let myUserId = userId;
        let gameLoopId;
        let groundScrollX = 0;
        let obstaclePool = [];
        let explosionPool = [];
        let currentRound = 1; // Moved to top level

        // Character Selection State
        let selectedCharIndex = 0;
        let isCharSelected = false;
        let selAnimFrame = 0;
        let selAnimTimer = 0;
        let lastMMRChange = null;

        // --- Socket Events ---
        socket.on('connect', () => {
            connectionStatus.textContent = `‚úÖ Connected as ${username}`;
            connectionStatus.style.color = '#4caf50';
            socket.emit('authenticate', { userId, username });
        });

        socket.on('authenticated', (data) => {
            quickMatchBtn.disabled = false;
            if (data.mmr) {
                const tier = getTier(data.mmr);
                const rankEl = document.getElementById('my-rank');
                rankEl.innerHTML = `<span style="color:${tier.color}">[${tier.name}]</span> ${data.mmr} MMR`;
            }
        });

        socket.on('disconnect', () => {
            connectionStatus.textContent = '‚ùå Disconnected';
            connectionStatus.style.color = '#ff4444';
            quickMatchBtn.disabled = true;
        });

        socket.on('waitingForOpponent', () => {
            quickMatchBtn.style.display = 'none';
            cancelMatchBtn.style.display = 'inline-block';
            matchStatus.textContent = '‚è≥ Searching for opponent...';
        });

        socket.on('matchFound', (data) => {
            currentRoom = data.roomId;
            myRole = data.player1.userId === userId ? 'player1' : 'player2';
            document.getElementById('p1-name').innerText = data.player1.username;
            document.getElementById('p2-name').innerText = data.player2.username;
            lobbyScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            charSelectScreen.style.display = 'flex';

            initCharSelect();
        });

        socket.on('playerReadyUpdate', (data) => {
            document.getElementById('opponent-status').textContent =
                `Opponent: ${data.readyCount}/2 Ready`;
        });
        // [Ï∂îÍ∞Ä] Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù ÏóÖÎç∞Ïù¥Ìä∏ (Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÏÑ†ÌÉùÌñàÏùÑ Îïå)
        socket.on('charSelectedUpdate', (data) => {
            // ÎÇ¥Í∞Ä ÏïÑÎãå Îã§Î•∏ ÏÇ¨ÎûåÏù¥ ÏÑ†ÌÉùÌïú Ï∫êÎ¶≠ÌÑ∞ÎùºÎ©¥ ÎπÑÌôúÏÑ±Ìôî Î™©Î°ùÏóê Ï∂îÍ∞Ä

            // Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú Ï∫êÎ¶≠ÌÑ∞ Î™©Î°ù Í¥ÄÎ¶¨ (Ï†ÑÏó≠ Î≥ÄÏàò ÌïÑÏöî)
            if (!window.takenChars) window.takenChars = [];
            window.takenChars.push(data.charId);

            // ÎÇ¥ ÏÑ†ÌÉùÏù¥ ÏÑ±Í≥µÌïú Í≤ΩÏö∞
            if (data.userId === userId) {
                isCharSelected = true;
                // Ïù¥Ï†ú Ï§ÄÎπÑ ÏôÑÎ£å Ïã†Ìò∏ Î≥¥ÎÉÑ
                socket.emit('playerReady', {
                    roomId: currentRoom,
                    charId: data.charId
                });
            }
            updateCharSelectUI(); // UI Í∞±Ïã†
            // }
        });

        // [Ï∂îÍ∞Ä] Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù Ïã§Ìå® (Ï§ëÎ≥µ ÏÑ†ÌÉù Ïãú)
        socket.on('charSelectFail', (data) => {
            alert(data.message); // "Character already taken" ÏïåÎ¶º
            isCharSelected = false; // ÏÑ†ÌÉù ÏÉÅÌÉú Ìï¥Ï†ú
            updateCharSelectUI();
        });

        socket.on('gameStart', (data) => {
            charSelectScreen.style.display = 'none';
            // Preload assets if needed
            startGameLoop();
        });

        socket.on('gameState', (serverState) => {
            renderGame(serverState);
        });

        socket.on('roundEnd', (data) => {
            // Show round end message? 
            // For now, server handles logic, we just wait for next round start or game over
            // But we might want to show a "Round 2" overlay
        });
        socket.on('mmrUpdate', (data) => {

            const newMMR = data[userId];
            if (newMMR) {
                lastMMRChange = newMMR;
                const tier = getTier(newMMR);


                // Î°úÎπÑ Îû≠ÌÅ¨ ÏóÖÎç∞Ïù¥Ìä∏
                const rankEl = document.getElementById('my-rank');
                if (rankEl) {
                    rankEl.innerHTML = `<span style="color:${tier.color}">[${tier.name}]</span> ${newMMR} MMR`;
                }
            }
        });

        async function showGameOverScreen(winnerMsg, reasonMsg) {
            console.log('showGameOverScreen called', winnerMsg, reasonMsg);
            els.winnerMsg.innerText = winnerMsg;
            els.gameOverReason.innerText = reasonMsg;

            // MMR Change Display
            const mmrDisplay = document.getElementById('mmr-change-display');
            if (lastMMRChange) {
                const tier = getTier(lastMMRChange);
                mmrDisplay.innerHTML = `New MMR: <span style="color:${tier.color}">${lastMMRChange}</span>`;
            } else {
                mmrDisplay.innerHTML = '';
            }

            // Fetch Leaderboard
            try {
                console.log('Fetching leaderboard...');
                const res = await fetch(`${API_URL}/api/leaderboard/mmr?limit=10`);
                const data = await res.json();
                console.log('Leaderboard data:', data);
                const tbody = document.querySelector('#leaderboard-table tbody');
                tbody.innerHTML = '';

                data.leaderboard.forEach((user, index) => {
                    const row = document.createElement('tr');
                    const tier = getTier(user.mmr);
                    row.innerHTML = `
                        <td style="padding: 8px;">#${index + 1}</td>
                        <td style="padding: 8px; color: ${user.username === username ? '#00c6ff' : 'white'}">${user.username}</td>
                        <td style="padding: 8px; color: ${tier.color}">${user.mmr}</td>
                    `;
                    tbody.appendChild(row);
                });
            } catch (err) {
                console.error('Failed to load leaderboard', err);
            }

            els.gameOver.style.display = 'flex';
        }

        // Button Handlers
        document.getElementById('go-lobby-btn').addEventListener('click', () => {
            location.reload();
        });

        document.getElementById('play-again-btn').addEventListener('click', () => {
            els.gameOver.style.display = 'none';
            // Reset Game State UI
            gameContainer.style.display = 'none';
            lobbyScreen.style.display = 'block';
            // Trigger Quick Match
            socket.emit('quickMatch');
            // Show waiting UI
            quickMatchBtn.style.display = 'none';
            cancelMatchBtn.style.display = 'inline-block';
            matchStatus.textContent = '‚è≥ Searching for opponent...';
        });



















        // [Ï∂îÍ∞Ä] Ìã∞Ïñ¥ Í≥ÑÏÇ∞ Ìï®Ïàò
        function getTier(mmr) {
            if (mmr < 1100) return { name: 'BRONZE', color: '#cd7f32' };
            if (mmr < 1300) return { name: 'SILVER', color: '#c0c0c0' };
            if (mmr < 1500) return { name: 'GOLD', color: '#ffd700' };
            if (mmr < 1800) return { name: 'PLATINUM', color: '#00ced1' };
            if (mmr < 2200) return { name: 'DIAMOND', color: '#b9f2ff' };
            return { name: 'MASTER', color: '#ff00ff' };
        }
        // --- Character Selection ---
        function initCharSelect() {
            window.takenChars = [];
            const grid = document.getElementById('char-grid');
            grid.innerHTML = '';

            CONFIG.characters.forEach((char, index) => {
                const card = document.createElement('div');
                card.className = 'char-card';
                card.id = `char-card-${index}`;

                const preview = document.createElement('div');
                preview.className = 'char-preview';
                preview.style.backgroundImage = `url('assets/${char}.png')`;

                const name = document.createElement('div');
                name.className = 'char-name';
                name.innerText = char;

                card.appendChild(preview);
                card.appendChild(name);
                grid.appendChild(card);
            });

            updateCharSelectUI();
            requestAnimationFrame(animateCharSelect);
        }
        function updateCharSelectUI() {
            document.querySelectorAll('.char-card').forEach((card, index) => {
                const charName = CONFIG.characters[index];
                const isTaken = window.takenChars && window.takenChars.includes(charName);

                // ÏÑ†ÌÉùÎêú Ïπ¥Îìú ÌëúÏãú
                if (index === selectedCharIndex) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }

                // Ìà¨Î™ÖÎèÑ Ï≤òÎ¶¨
                if (isTaken) {
                    card.style.opacity = '0.3'; // Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú Ï∫êÎ¶≠ÌÑ∞Îäî ÌùêÎ¶¨Í≤å
                    card.style.filter = 'grayscale(100%)'; // ÌùëÎ∞± Ï≤òÎ¶¨
                } else if (isCharSelected) {
                    card.style.opacity = index === selectedCharIndex ? '1' : '0.5';
                    card.style.filter = 'none';
                } else {
                    card.style.opacity = '1';
                    card.style.filter = 'none';
                }
            });
        }
        function animateCharSelect(timestamp) {
            if (charSelectScreen.style.display === 'none') return;

            // Animate sprites
            if (!selAnimTimer) selAnimTimer = timestamp;
            if (timestamp - selAnimTimer > 150) {
                selAnimFrame = (selAnimFrame + 1) % 4;
                selAnimTimer = timestamp;

                document.querySelectorAll('.char-preview').forEach((el, index) => {
                    el.style.backgroundPosition = `-${selAnimFrame * 64}px 0`;
                });
            }

            requestAnimationFrame(animateCharSelect);
        }

        // --- Game Rendering ---
        function startGameLoop() {
            // Nothing to do here really, as we render on server updates
            // But we might want to interpolate?
            // For now, just rely on socket 'gameState' events
        }

        function renderGame(state) {
            // Update Round
            currentRound = state.round;

            // 1. UI Updates
            els.timer.innerText = state.timer;
            if (state.timer <= 10) els.timer.classList.add('warning');
            else els.timer.classList.remove('warning');

            els.p1Score.innerText = state.scores.p1;
            els.p2Score.innerText = state.scores.p2;

            // Stamina Bar
            els.staminaBar.style.width = state.stamina + '%';
            els.staminaText.innerText = Math.floor(state.stamina) + '%';

            // Position Stamina Box (Follow Attacker)
            const attacker = state.round === 1 ? state.p2 : state.p1;
            els.staminaBox.style.left = (attacker.x + 4) + 'px';
            els.staminaBox.style.bottom = (attacker.y + 40) + 'px';

            // 2. Render Players
            renderPlayer(els.p1, state.p1, state.cooldowns);
            renderPlayer(els.p2, state.p2, state.cooldowns);

            // 3. Render Obstacles
            renderObstacles(state.obstacles);

            // 4. Render Explosions
            renderExplosions(state.explosions);

            // 5. Ground Scroll
            if (state.round === 1) {
                groundScrollX = (groundScrollX + state.speed) % 800;
            } else {
                groundScrollX = (groundScrollX - state.speed + 800) % 800;
            }
            els.ground.style.backgroundPosition = `-${groundScrollX}px 0`;

            // 6. Game Over
            if (state.isGameOver) {
                console.log('Game Over state detected');
                if (els.gameOver.style.display === 'flex') return;

                let winner = "";
                if (state.scores.p1 > state.scores.p2) winner = "PLAYER 1 WINS!";
                else if (state.scores.p2 > state.scores.p1) winner = "PLAYER 2 WINS!";
                else winner = "DRAW!";

                showGameOverScreen(winner, `Score: ${state.scores.p1} - ${state.scores.p2}`);
            }










        }

        function renderPlayer(el, pState, cooldowns) {
            if (!pState) return; // Safety check

            el.style.backgroundImage = `url('assets/${pState.char}.png')`;

            // Determine Frame
            let frameIndex = 0;
            const now = Date.now();
            const runFrame = Math.floor(now / 100) % 6;

            if (pState.isJumping) {
                frameIndex = 12; // Jump
            } else if (pState.isSneaking) {
                frameIndex = 18 + runFrame; // Sneak
            } else {
                frameIndex = 4 + runFrame; // Run
            }

            el.style.backgroundPosition = `-${frameIndex * 64}px 0`;

            // Position
            const spriteOffset = 16; // (64-32)/2
            el.style.left = (pState.x - spriteOffset) + 'px';
            el.style.bottom = (pState.y - spriteOffset) + 'px';

            // Transform (Flip/Rotate)
            const scaleX = pState.facingRight ? 1 : -1;
            const rotate = (pState.role === 'runner' && pState.isJumping) ? -pState.vy * 2 : 0;

            el.style.transform = `scaleX(${scaleX}) rotate(${rotate}deg)`;

            // Cooldown effect
            if (pState.role === 'attacker' && (cooldowns?.wall > 0 || cooldowns?.bullet > 0)) {
                el.classList.add('cooldown');
            } else {
                el.classList.remove('cooldown');
            }
        }

        function renderObstacles(obstacles) {
            // Hide all existing
            obstaclePool.forEach(el => el.style.display = 'none');

            obstacles.forEach((obs, index) => {
                let el = obstaclePool[index];
                if (!el) {
                    el = document.createElement('div');
                    els.obsLayer.appendChild(el);
                    obstaclePool.push(el);
                }

                el.style.display = 'block';
                el.className = 'obstacle ' + obs.type;

                if (obs.type === 'bullet') {
                    el.style.width = '96px';
                    el.style.height = '96px';
                    el.style.backgroundImage = "url('assets/fireball.png')";
                    el.style.backgroundSize = 'auto 96px';
                    // Animation
                    const frame = Math.floor(Date.now() / 50) % 14;
                    el.style.backgroundPosition = `-${frame * 96}px 0`;

                    el.style.left = (obs.x - 24) + 'px'; // Center adjustment
                    el.style.bottom = (obs.y - 42) + 'px';

                    // Flip based on direction (speed < 0 means moving left)
                    el.style.transform = obs.speed < 0 ? 'scaleX(-1)' : 'scaleX(1)';
                } else {
                    el.style.width = obs.w + 'px';
                    el.style.height = obs.h + 'px';
                    el.style.backgroundImage = "url('assets/wall.png')";
                    el.style.backgroundSize = '20px auto';
                    el.style.left = obs.x + 'px';
                    el.style.bottom = obs.y + 'px';
                    el.style.transform = 'none';
                }
            });
        }

        function renderExplosions(explosions) {
            explosions.forEach((exp, index) => {
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.width = '48px';
                el.style.height = '48px';
                el.style.backgroundImage = "url('assets/explosion.png')";
                el.style.backgroundSize = 'auto 48px';
                el.style.imageRendering = 'pixelated';
                el.style.zIndex = '12';
                el.style.left = (exp.x - 8) + 'px';
                el.style.bottom = (exp.y - 8) + 'px';
                els.obsLayer.appendChild(el);

                // Animate
                let frame = 0;
                const interval = setInterval(() => {
                    frame++;
                    if (frame >= 9) {
                        clearInterval(interval);
                        el.remove();
                    } else {
                        el.style.backgroundPosition = `-${frame * 48}px 0`;
                    }
                }, 50);
            });
        }

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => {
            if (charSelectScreen.style.display !== 'none') {
                if (isCharSelected) return;

                if (e.key === 'ArrowLeft') {
                    selectedCharIndex = (selectedCharIndex - 1 + CONFIG.characters.length) % CONFIG.characters.length;
                    updateCharSelectUI();
                } else if (e.key === 'ArrowRight') {
                    selectedCharIndex = (selectedCharIndex + 1) % CONFIG.characters.length;
                    updateCharSelectUI();
                } else if (e.key === ' ' || e.key === 'Enter') {

                    const charName = CONFIG.characters[selectedCharIndex];

                    // [Ï∂îÍ∞Ä] Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú Ï∫êÎ¶≠ÌÑ∞Ïù∏ÏßÄ ÌôïÏù∏
                    if (window.takenChars && window.takenChars.includes(charName)) {
                        const card = document.getElementById(`char-card-${selectedCharIndex}`);
                        card.classList.add('charging'); // Í∏∞Ï°¥ shake Ïï†ÎãàÎ©îÏù¥ÏÖò Ïû¨ÌôúÏö©
                        setTimeout(() => card.classList.remove('charging'), 200); // 0.2Ï¥à Îí§ Î©àÏ∂§
                        return;
                    }


                    socket.emit('selectChar', {
                        roomId: currentRoom,
                        charId: CONFIG.characters[selectedCharIndex]
                    });
                }
                return;
            }

            if (!currentRoom) return;

            if (e.repeat) return; // Ignore hold for some keys

            const isP1 = myRole === 'player1';
            const isRunner = (isP1 && currentRound === 1) || (!isP1 && currentRound === 2);

            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                if (isRunner) {
                    socket.emit('playerInput', { roomId: currentRoom, input: { type: 'jump' } });
                } else {
                    socket.emit('playerInput', { roomId: currentRoom, input: { type: 'fire_bullet' } });
                }
            }

            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                if (isRunner) {
                    socket.emit('playerInput', { roomId: currentRoom, input: { type: 'sneak_start' } });
                } else {
                    socket.emit('playerInput', { roomId: currentRoom, input: { type: 'charge_start' } });
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (charSelectScreen.style.display !== 'none') return;

            const isP1 = myRole === 'player1';
            const isRunner = (isP1 && currentRound === 1) || (!isP1 && currentRound === 2);

            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                if (isRunner) {
                    socket.emit('playerInput', { roomId: currentRoom, input: { type: 'sneak_end' } });
                } else {
                    socket.emit('playerInput', { roomId: currentRoom, input: { type: 'charge_end' } });
                }
            }
        });

        // Button Events
        quickMatchBtn.addEventListener('click', () => {
            socket.emit('quickMatch');
        });

        cancelMatchBtn.addEventListener('click', () => {
            socket.emit('cancelWaiting');
        });
    </script>
</body>

</html>
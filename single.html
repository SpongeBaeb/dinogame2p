<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Runner vs Attacker (Local 2P) - Round System</title>
    <!-- Í≥µÌÜµ Í≤åÏûÑ ÏóîÏßÑ -->
    <script src="js/config.js"></script>
    <script src="js/game-engine.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #222;
            font-family: 'Consolas', monospace;
            color: white;
            overflow: hidden;
            user-select: none;
        }

        .pixel-art {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #game-container {
            width: 800px;
            height: 300px;
            border: 4px solid #666;
            background-image: url('assets/background.png');
            background-size: cover;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);

            /* [ÏàòÏ†ï] Î∞∞Í≤Ω ÏúÑÏπò Ï°∞Ï†ï */
            /* center: Í∞ÄÎ°úÎäî Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨ */
            /* -50px: ÏÑ∏Î°úÎäî ÏúÑÎ°ú 50px Ïù¥Îèô (ÏõêÌïòÎäî ÎßåÌÅº Ïà´ÏûêÎ•º Î∞îÍæ∏ÏÑ∏Ïöî) */
            background-position: center -50px;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            z-index: 20;
            box-sizing: border-box;
            pointer-events: none;
        }

        #p1-status,
        #p2-status {
            width: 250px;
        }

        #p2-status {
            text-align: right;
        }

        .large-score {
            color: #0056b3;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 1px 1px 0 #fff;
        }

        #timer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #333;
            text-shadow: 2px 2px 0 #fff;
            z-index: 21;
        }

        #timer.warning {
            color: #ff4444;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.1);
            }
        }

        #stamina-box {
            position: absolute;
            /* relative ‚Üí absolute */
            width: 80px;
            /* 100% ‚Üí 80px (Í≥†Ï†ï ÌÅ¨Í∏∞) */
            height: 12px;
            /* 15px ‚Üí 12px (ÏûëÍ≤å) */
            background: #333;
            border: 2px solid #000;
            border-radius: 10px;
            overflow: hidden;
            z-index: 25;
            /* ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏóê ÌëúÏãú */
            /* ÏúÑÏπòÎäî JavaScriptÏóêÏÑú ÎèôÏ†Å ÏÑ§Ï†ï */
        }

        #stamina-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ffcc00, #ff4444);
            transition: width 0.1s linear;
        }

        #stamina-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-size: 10px;
            line-height: 15px;
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
        }

        .status-indicator {
            position: absolute;
            bottom: 80px;
            right: 40px;
            font-weight: bold;
            font-size: 14px;
            display: none;
            z-index: 30;
        }

        .charging {
            animation: player-shake 0.1s infinite !important;
        }


        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-2px);
            }

            75% {
                transform: translateX(2px);
            }
        }

        #ground {
            width: 100%;
            height: 45px;
            background-image: url('assets/ground.png');
            overflow: hidden;
            background-size: auto 45px;
            background-repeat: repeat-x;
            background-position: 0 0;
            position: absolute;
            bottom: -5px;
            left: 0;
            z-index: 10;
        }

        #debug-box {
            position: absolute;
            border: 2px solid lime;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            z-index: 20;
        }

        #player1,
        #player2 {
            position: absolute;
            width: 64px;
            height: 64px;
            background-repeat: no-repeat;
            background-size: auto 64px;
            z-index: 15;
        }

        #player2.cooldown {
            filter: grayscale(100%);
            opacity: 0.7;
        }

        .obstacle {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 11;
            will-change: transform;
            /* üëá Ï∂îÍ∞Ä */
            backface-visibility: hidden;
            perspective: 1000px;
        }

        .wall {
            width: 20px;
            background-image: url('assets/wall.png');
            background-size: 20px auto;
            background-repeat: repeat-y;
            background-position: center bottom;
            border: 1px solid #222;
            border-radius: 3px 3px 0 0;
        }

        .bullet {
            width: 64px;
            height: 64px;
            background-image: url('assets/fireball.png');
            background-size: auto 96px;
            background-repeat: no-repeat;
            image-rendering: pixelated;
        }

        /* Character Selection UI */
        #char-select {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        #char-grid {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .char-card {
            width: 100px;
            height: 140px;
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #222;
            position: relative;
            transition: all 0.2s;
        }

        .char-card.selected-p1 {
            border-color: #007bff;
            box-shadow: 0 0 15px #007bff;
        }

        .char-preview {
            width: 64px;
            height: 64px;
            background-repeat: no-repeat;
            background-size: auto 64px;
            image-rendering: pixelated;
            margin-bottom: 10px;
        }

        .char-name {
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .p1-cursor,
        .p2-cursor {
            position: absolute;
            top: -10px;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .p1-cursor {
            left: 50%;
            transform: translateX(-50%);
            background: #007bff;
        }

        .p2-cursor {
            left: 50%;
            transform: translateX(-50%);
            background: #ff4444;
            top: auto;
            bottom: -10px;
        }

        .controls-hint {
            margin-top: 20px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        #sliders {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px 20px;
            width: 90%;
            max-width: 700px;
        }

        .slider-container {
            margin: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            font-size: 11px;
        }

        .slider-container label {
            flex: 1;
            text-align: left;
            margin-right: 5px;
            white-space: nowrap;
        }

        .slider-container input {
            width: 80px;
        }

        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 60;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <!-- Character Selection UI -->
        <div id="char-select">
            <h1>SELECT YOUR CHARACTER</h1>
            <div id="char-grid"></div>
            <div class="controls-hint">
                <div class="p1-hint">P1: A/D to Move, SPACE to Select</div>
                <div class="p2-hint">P2: Arrows to Move, ENTER to Select</div>
            </div>
        </div>

        <div id="ui-layer">
            <div id="p1-status">
                <div style="color:#007bff; font-weight:bold; margin-bottom:5px;">P1</div>
                <div class="large-score">0</div>
            </div>
            <div id="timer">60</div>
            <div id="p2-status">
                <div style="color:#ff4444; font-weight:bold; margin-bottom:5px;">P2</div>
                <div class="large-score">0</div>
            </div>
        </div>

        <div id="ground"></div>
        <div id="obstacles-layer"></div>
        <div id="stamina-box">
            <div id="stamina-bar"></div>
            <div id="stamina-text">100</div>
        </div>
        <div id="player1" class="pixel-art"></div>
        <div id="player2" class="pixel-art"></div>

        <div id="debug-box"></div>
        <!-- FPS COUNTER (DELETE LATER) -->
        <div id="fps-counter"
            style="position: absolute; top: 5px; right: 5px; color: lime; font-weight: bold; z-index: 100; font-family: monospace;">
            FPS: 0</div>
        <!-- END FPS COUNTER -->

        <div class="status-indicator" id="charge-indicator">‚ö†Ô∏è CHARGING!</div>
        <div class="status-indicator" id="cooldown-indicator">‚è≥ COOLDOWN</div>
        <div class=" status-indicator" id="bomb-indicator" style="bottom: 110px; color: orange;">üí£ BOMB READY</div>

        <div id="start-screen" style="display: none;">
            <h1>RUNNER VS ATTACKER</h1>
            <p>Round 1: P1 Runs, P2 Attacks</p>
            <p>Round 2: Roles Swap</p>
            <p class="blink">PRESS SPACE TO START</p>

            <div style="margin-top: 20px; font-size: 14px; color: #aaa;">
                <p>P1 Controls: W (Jump), S (Sneak/Charge)</p>
                <p>P2 Controls: ARROWS (Move/Attack)</p>
            </div>

            <div id="sliders">
                <div class="slider-container">
                    <label>Wall Tile Size: <span id="val-wall-tile">40</span></label>
                    <input type="range" id="input-wall-tile" min="10" max="100" value="40">
                </div>
                <div class="slider-container">
                    <label>Ground Speed: <span id="val-ground-speed">3</span></label>
                    <input type="range" id="input-ground-speed" min="0" max="20" value="3">
                </div>
                <div class="slider-container">
                    <label>Stamina Regen Wait: <span id="val-regen">1000</span>ms</label>
                    <input type="range" id="input-regen" min="0" max="5000" value="1000" step="100">
                </div>
                <!-- New Sliders -->
                <div class="slider-container">
                    <label>Recoil Jump: <span id="val-recoil-jump">5</span></label>
                    <input type="range" id="input-recoil-jump" min="0" max="20" value="5">
                </div>
                <div class="slider-container">
                    <label>Recoil Lookback: <span id="val-recoil-time">20</span> frames</label>
                    <input type="range" id="input-recoil-time" min="0" max="60" value="20">
                </div>

            </div>
        </div>
    </div>

    <div id="game-over" style="display:none;">
        <h1 id="winner-msg">GAME OVER</h1>
        <p>Press SPACE to Restart</p>
        <button onclick="location.reload()">üîÑ Reset All</button>
    </div>
    </div>
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.position = 'fixed';
            div.style.top = '0';
            div.style.left = '0';
            div.style.width = '100%';
            state.lastWallTime = now;
            state.stamina -= CONFIG.wallBaseCost;

            const spawnX = (state.round === 1) ? 700 : 50;
            const spd = (state.round === 1) ? -CONFIG.wallSpeed : CONFIG.wallSpeed;

            state.obs.push({
                type: 'wall',
                x: spawnX,
                y: 40,
                w: 20,
                h: wallTileSize,
                spd: spd,
                passed: false
            });
        }

        function spawnBullet(now) {
            if (now - state.lastBulletTime < CONFIG.bulletCooldown) return;
            if (state.stamina < CONFIG.bulletCost) return;

            state.lastBulletTime = now;
            state.stamina -= CONFIG.bulletCost;
            // Apply Recoil
            state.p2Vy = CONFIG.recoilJumpForce;
            state.recoilTimer = CONFIG.recoilDuration;


            const spawnX = (state.round === 1) ? 700 : 50;
            const spd = (state.round === 1) ? -CONFIG.bulletSpeed : CONFIG.bulletSpeed;

            // Random height between 50 and 150
            const y = 70

            state.obs.push({
                type: 'bullet',
                x: spawnX,
                y: y,
                w: 48,
                h: 12,
                spd: spd,
                passed: false,
                animFrame: 0,  // Add this for animation
                animTimer: 0   // Add this for animation timing
            });
        }

        function spawnExplosion(x, y) {
            state.explosions.push({
                x: x,
                y: y,
                frame: 0,
                timer: 0,
                lifetime: 0
            });
        }

        function render(now) {
            // Render Player 1 (Runner)
            const charName = (state.round === 1) ? state.p1Char : state.p2Char;

            // Frame Calculation
            let frameIndex = 0;
            if (state.anim.state === 'run') {
                frameIndex = 4 + state.anim.frame; // Run frames 5-10 (indices 4-9)
            } else if (state.anim.state === 'jump') {
                frameIndex = 12; // Jump frame
            } else if (state.anim.state === 'fall') {
                frameIndex = 8; // Fall frame
            } else if (state.anim.state === 'sneak') {
                frameIndex = 18 + state.anim.frame; // Sneak frames start at 18
            }

            els.p1.style.backgroundImage = `url('assets/${charName}.png')`;
            els.p1.style.backgroundPosition = `-${frameIndex * 64}px 0`;

            // Offset to center 64px sprite on 32px collider
            const spriteOffset = (64 - p1Rect.w) / 2; // (64-32)/2 = 16px offset
            els.p1.style.left = (p1Rect.x - spriteOffset) + 'px';
            els.p1.style.bottom = (state.p1Y - spriteOffset) + 'px';
            // Flip left in round 2, rotate for jump
            const flipX = (state.round === 2) ? 'scaleX(-1)' : 'scaleX(1)';
            els.p1.style.transform = `${flipX} rotate(${state.p1Rot}deg)`;
            // Render Player 2 (Both players running)
            const p2CharName = (state.round === 1) ? state.p2Char : state.p1Char;
            els.p2.style.backgroundImage = `url('assets/${p2CharName}.png')`;
            const p2FrameIndex = 4 + state.p2Anim.frame; // P2's own running animation (frames 5-10)
            els.p2.style.backgroundPosition = `-${p2FrameIndex * 64}px 0`;
            const p2SpriteOffset = (64 - 32) / 2; // Same 16px offset
            els.p2.style.left = ((state.round === 1 ? 700 : 50) - p2SpriteOffset) + 'px';
            els.p2.style.bottom = (state.p2Y - p2SpriteOffset) + 'px';


            // Flip logic
            let p2Scale = (state.round === 2) ? -1 : 1;
            if (state.recoilTimer > 0) p2Scale *= -1; // Reverse direction during recoil
            els.p2.style.transform = `scaleX(${p2Scale})`;

            // Render Explosions - using object pooling
            state.explosions.forEach((exp, index) => {
                let expDiv = explosionPool[index];
                if (!expDiv) {
                    expDiv = document.createElement('div');
                    expDiv.style.position = 'absolute';
                    expDiv.style.width = '48px';
                    expDiv.style.height = '48px';
                    expDiv.style.backgroundImage = "url('assets/explosion.png')";
                    expDiv.style.backgroundSize = 'auto 48px';
                    expDiv.style.imageRendering = 'pixelated';
                    expDiv.style.zIndex = '12';
                    els.obsLayer.appendChild(expDiv);
                    explosionPool.push(expDiv);
                }
                expDiv.style.display = 'block';
                expDiv.style.left = exp.x + 'px';
                expDiv.style.bottom = exp.y + 'px';
                expDiv.style.backgroundPosition = `-${exp.frame * 48}px 0`;
            });

            // Hide unused explosion divs
            for (let i = state.explosions.length; i < explosionPool.length; i++) {
                explosionPool[i].style.display = 'none';
            }

            // Cooldown Visual
            if (state.stamina < CONFIG.wallBaseCost) {
                els.p2.classList.add('cooldown');
            } else {
                els.p2.classList.remove('cooldown');
            }

            // Render Obstacles - using object pooling for performance
            state.obs.forEach((o, index) => {
                // üëá ÌôîÎ©¥ Î∞ñÏù¥Î©¥ ÏôÑÏ†ÑÌûà Ïä§ÌÇµ
                if (o.x < -150 || o.x > 950) {
                    if (obstaclePool[index]) {
                        obstaclePool[index].style.display = 'none';
                    }
                    return;
                }

                // Reuse existing div or create new one
                let div = obstaclePool[index];
                if (!div) {
                    div = document.createElement('div');
                    els.obsLayer.appendChild(div);
                    obstaclePool.push(div);
                }

                div.style.display = 'block';
                div.className = 'obstacle ' + o.type;

                // For bullets, render larger than collision box
                if (o.type === 'bullet') {
                    const renderWidth = 96;
                    const renderHeight = 96;
                    const offsetX = (renderWidth - o.w) / 2;
                    const offsetY = (renderHeight - o.h) / 2;

                    div.style.left = (o.x - offsetX) + 'px';
                    div.style.bottom = (o.y - offsetY) + 'px';
                    div.style.width = renderWidth + 'px';
                    div.style.height = renderHeight + 'px';

                    // Animation
                    div.style.backgroundImage = "url('assets/fireball.png')";
                    div.style.backgroundSize = 'auto 96px';
                    div.style.backgroundRepeat = 'no-repeat';
                    div.style.backgroundPosition = `-${o.animFrame * 96}px 0`;
                    div.style.transform = (state.round === 1) ? 'scaleX(-1)' : 'scaleX(1)';

                    // Collision box visualization - REMOVE THIS FOR BETTER PERFORMANCE
                    // div.innerHTML = `...`;  // Comment this out or remove it
                } else {
                    // Normal rendering for walls
                    div.style.transform = `translate3d(${Math.round(o.x)}px, ${Math.round(-o.y)}px, 0)`;
                    div.style.left = '0';
                    div.style.bottom = '0';
                    div.style.width = o.w + 'px';
                    div.style.height = o.h + 'px';
                    div.style.backgroundImage = "url('assets/wall.png')";
                    div.style.backgroundSize = '20px auto';
                    div.style.backgroundRepeat = 'repeat-y';
                    div.style.backgroundPosition = 'center bottom';
                }
            });

            // Hide unused divs
            for (let i = state.obs.length; i < obstaclePool.length; i++) {
                obstaclePool[i].style.display = 'none';
            }

            // UI Updates - Only every 6 frames (~10Hz)
            frameCount++;
            if (frameCount % 6 === 0) {
                els.timer.innerText = Math.ceil((CONFIG.roundTime - (now - state.startTime)) / 1000);
                if (parseInt(els.timer.innerText) <= 10) els.timer.classList.add('warning');
                else els.timer.classList.remove('warning');

                // Í∞úÏÑ†
                els.p1Score.innerText = (state.round === 1) ? state.score : state.scores.p1;
                els.p2Score.innerText = (state.round === 2) ? state.score : state.scores.p2;
                els.staminaBar.style.width = state.stamina + '%';
                els.staminaText.innerText = Math.floor(state.stamina);
            }

            // Ground Scroll (Simple background)
            if (state.round === 1) {
                groundScrollX = (groundScrollX + groundSpeed) % 800;
            } else {
                groundScrollX = (groundScrollX - groundSpeed + 800) % 800;
            }
            els.ground.style.backgroundPosition = `-${groundScrollX}px 0`;
            // els.ground.style.backgroundPosition = `-${groundScrollX}px 0`;

            // üëá Ïä§ÌÉúÎØ∏ÎÇò Î∞î ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ (Í≥µÍ≤©Ïûê ÏúÑ)
            const attacker = state.round === 1 ? els.p2 : els.p1;
            const attackerX = state.round === 1 ? 684 : 40;
            const attackerY = state.round === 1 ? state.p2Y : state.p1Y;

            // üëá Ïä§ÌÉúÎØ∏ÎÇò Î∞î ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ (Í≥µÍ≤©ÏûêÎ•º Îî∞ÎùºÎã§Îãò)
            const staminaBox = document.getElementById('stamina-box');

            if (state.round === 1) {
                // ÎùºÏö¥Îìú 1: P2 ÏúÑ
                staminaBox.style.left = '676px';  // P2 X ÏúÑÏπò
                staminaBox.style.bottom = (state.p2Y + 40) + 'px';
            } else {
                // ÎùºÏö¥Îìú 2: P1 ÏúÑ
                staminaBox.style.left = '24px';  // P1 X ÏúÑÏπò
                staminaBox.style.bottom = (state.p2Y + 40) + 'px';
            }
        }

        // Input Handling
        window.addEventListener('keydown', e => {
            if (state.selectionPhase) {
                // P1 Selection Controls
                if (e.key === 'a' || e.key === 'A') {
                    if (!p1Confirmed) {
                        p1SelIndex = (p1SelIndex - 1 + CONFIG.characters.length) % CONFIG.characters.length;
                    }
                }
                if (e.key === 'd' || e.key === 'D') {
                    if (!p1Confirmed) {
                        p1SelIndex = (p1SelIndex + 1) % CONFIG.characters.length;
                    }
                }
                if (e.key === ' ') {
                    if (!p1Confirmed) {
                        // Check if taken by P2
                        if (p2Confirmed && p1SelIndex === p2SelIndex) return;
                        p1Confirmed = true;
                    }
                }
                return;
            }

            // [NEW] Start Screen Controls
            if (state.startScreen) {
                if (e.code === 'Space') {
                    state.startScreen = false;
                    document.getElementById('start-screen').style.display = 'none';
                    startGame();
                }
                return;
            }

            if (!state.isPlaying) {
                if (e.code === 'Space') {
                    // Restart game after game over
                    location.reload();
                }
                return;
            }

            // P1 Controls (Runner in Round 1, Attacker in Round 2)
            if (state.round === 1) {
                // P1 is Runner
                if (e.key === 'w' || e.key === 'W') {
                    if (state.jumpCount < 2) {
                        state.p1Vy = CONFIG.jumpForce;
                        state.p1Jump = true;
                        state.jumpCount++;

                        // Spawn explosion on double jump
                        if (state.jumpCount === 2) {
                            spawnExplosion(p1Rect.x - 16, state.p1Y - 10);  // Below player
                        }
                    }
                }
                if (e.key === 's' || e.key === 'S') {
                    state.p1Sneak = true;
                    if (state.p1Y > 40) state.p1Vy = -6;
                }
            } else {
                // P1 is Attacker
                if (e.key === 's' || e.key === 'S') {
                    if (!state.isCharging && state.stamina >= CONFIG.wallBaseCost) {
                        state.isCharging = true;
                        state.chargeStart = Date.now();
                    }
                }
                if (e.key === 'w' || e.key === 'W') {
                    spawnBullet(Date.now());
                }
            }

        });

        window.addEventListener('keyup', (e) => {
            if (state.selectionPhase) return;

            // P1 Charge Release
            if (state.round === 2 && (e.key === 's' || e.key === 'S')) {
                if (state.isCharging) {
                    spawnWall(Date.now());
                    state.isCharging = false;
                    state.lastActionTime = Date.now();
                }
            }

            // P1 Sneak Release
            if (state.round === 1 && (e.key === 's' || e.key === 'S')) {
                state.p1Sneak = false;
            }

        });

        initGame();
    </script>
</body>

</html>